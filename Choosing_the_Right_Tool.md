# Choosing the Right Tool

I will use text editors as the concrete example in this post, but the message can more broadly apply to all tools in the developer toolchain.

## Why

I think it's important to reflect on the tools we use daily for multiple reasons. First, I'm not a productivity zealot, but there are more likely than not some painful inefficiencies in your day-to-day tasks. These could potentially be solved by adding new tools or changing the current tools that you work with. An example could be that you really like using [Notepad++](https://survey.stackoverflow.co/2023/#section-most-popular-technologies-integrated-development-environment), but it doesn't have a sophisticated LSP, so you're working on a Java project for example, you could gain a lot more productivity by transitioning to an IDE like IntelliJ. Second, you could learn something new or gain a new perspective. Continuous learning has become kind of a meaningless buzzword at this point, but if you have genuine curiosity then investigating new tools and learning them, even if you revert back to your old ways, is a great way to gain new perspectives and learn new ways of doing things. Finally, you will be a better software engineer. There are only a few possible outcomes when using a new tool: you enjoy the tool and it objectively increases your productivity, you enjoy the tool and it has negligible impact on your productivity, you don't like the tool and stop using it. In those scenarios, you either end up more productive, happier, and therefore [more productive](https://www.wellsteps.com/blog/2022/05/17/happy-employees-more-productive/#:~:text=Does%20Employee%20Happiness%20Have%20an,the%20workplace%20than%20unhappy%20employees.), or you've learned something new or gained a new perspective which could possibly improve your productivity with your old tooling.

## My History

As far as my history with editors and IDEs, I believe I first began programming on my own in C++ using Microsoft's Visual Studio in high school. I didn't give the choice of tooling that much thought when starting out as I was still struggling with the basics of programming. When I finally took my first college course the language taught at the time was MIT Scheme which is a Lisp variant. The instructor also recommended Emacs as the editor. This was my first time using a general text editor and looking back now, I just barely scratched the surface of Emacs' potential. My second semester was Java and the recommended IDE was Netbeans. Since the course was in Java, which has tremendous amounts of boilerplate, it was a nice starting point. I moved on to Sublime Text and a bunch of other Mac-specific editors that I've forgotten the names of, and then later in college a new editor came out, called VSCode. VSCode became my main driver and I still use it to this day for simple text editing like the Markdown needed for this post. My first job was mostly Java and Oracle SQL and I used Intellij. This is where I sort of began my multifaceted approach to tooling. I worked on an HVD which was painfully slow for Intellij, so VSCode helped to write PL/SQL scripts or any other basic text editing. Maybe a year after starting, I discovered an editor called Neovim.

## [Neovim](https://neovim.io/)

Neovim is a project that began in order to modernize the classic text editor Vim. It is written in Lua and has been modified in order to let the community extend it however they need. The plugin support, while it takes a bit to learn, is nothing short of phenomenal. Additionally, you can essentially customize every single aspect of it. Then all you need to do is push your config to a GitHub repository and then can pull it to any Linux machine that has Neovim installed. TJ Devries has an excellent Github repository called [kickstart](https://github.com/nvim-lua/kickstart.nvim) that will get you up and running quickly. You do have to learn a lot of new ways of doing things, but I found it felt natural from the start. I think Neovim, as well as Emacs, are so flexible that they make most IDEs unnecessary. I say most because I still believe IntelliJ to be a superior experience for Java development. The sheer quantity of plugins developed by the community to solve many common problems in development workflows is insane. There is a language server plugin for downloading any number of open-source language servers. There are plugins for fuzzy-finding text in files over an entire git repository, a directory, or a file. There are plugin managers to make it much easier to quickly add plugins to your config. There are just so many ways to customize and extend the editor, that if you want it to become VSCode, you could make it that. I don't believe you should though. I think if you want VSCode you should stick with VSCode or VSCodium. If you don't like working in the terminal, and you prefer user interfaces to text, then I won't recommend you switch to Neovim. I will still implore you to try Vim motions if your editor or IDE has them as a plugin or setting somewhere. Vim motions for navigating around the text are hands down the best feeling way to edit. The speed you are able to move around a file puts computer mice to shame.

## IDEs vs Text Editors

I think IDEs shine mostly with their visual debuggers. A lot of the time you can get away with the classic "printf" debugging, but for very complicated systems with complicated states, debuggers can be invaluable. The biggest problems with IDEs are how bloated they become and how specific they are. IDEA has tried to solve this problem by making an IDE for everything from their base IDE. It feels like trying to pound a round peg into a square hole sometimes though. For the most part, these IDEs are created for their niche. Which is fine if you're only working on C++ for example. But if you're working on a Go backend, a React frontend, and a Linux batch system. There isn't really an IDE that can help you. That's where the importance of choosing a text editor comes in.

## Tooling at Large

For most of this post, I discussed tooling using the concrete example of IDEs and text editors. This can apply to debuggers, API testing software, testing libraries, and so on. There are so many things out there that you can't even know what you are missing. That's why it's always important to read or listen to what others are doing and if you notice something new, look into it. At the very least, a little investigation will cost you a small amount of time. I don't think it just stops at workflow tooling either. I think that for implementing software systems, there can be multiple tools that are correct for the given requirements. It's important that you learn about as many as possible so you don't end up forcing an approach on a problem. If you only have a hammer, every problem begins to look like a nail.

## Conclusion

I think choosing the right tool for the right job can have a very large impact on your productivity and happiness when working. However, I don't believe there is any singular "right" tool for any job, and it can vary from person to person based on preferences. I think you ultimately do yourself a disservice if you don't at least learn what's out there to gain a fresh perspective and teach yourself something new. Even if it's something that you don't stick with.